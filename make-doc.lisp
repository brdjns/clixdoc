
(in-package "CLIXDOC")

(defmacro with-clix-element ((name) &body body)
  `(with-element* ("clix" ,name)
     ,@body))

(defun clix-name-attribute (name)
  (attribute "name" (string-downcase (princ-to-string name))))

(defvar *current-doc-entries* nil
  "List of current doc entries, used to generate cross references")

(defun clix-description (doc &key args)
  (with-clix-element ("description")
    (if doc
        (let ((pos 0)
              (args (alexandria:flatten args)))
          (text #.(format nil "~%"))
          (cl-ppcre:do-matches (match-start match-end "[*+]?[A-Z0-9-]+[*+]?" doc)
            (let ((name (subseq doc match-start match-end)))
              (text (subseq doc pos match-start))
              (cond
                ((find name args :test #'string-equal)
                 (with-clix-element ("arg")
                   (text (string-downcase name))))
                ((find name *current-doc-entries* :key #'first :test #'string-equal)
                 (with-clix-element ("ref")
                   (text name)))
                (t
                 (text name)))
              (setf pos match-end)))
          (text (subseq doc pos))
          (text #.(format nil "~%")))
        (text "**DOCSTRING-MISSING**"))))

(defmacro with-clix-chapter ((name title) &body body)
  `(with-clix-element ("chapter")
     (attribute "name" ,name)
     (attribute "title" ,title)
     ,@body))

(defgeneric process-doc-entry (name type args doc &key)
  (:method (name type args doc &key)
    (warn "ignored ~(~A ~S~)" type name))
  (:method (name (type (eql :method)) args doc &key specializers qualifiers)
    (declare (ignore name args doc specializers qualifiers))
    #| nothing is generated for methods currently |#)
  (:method (name (type (eql :function)) args doc &key macro generic)
    (with-clix-element ("function")
      (clix-name-attribute name)
      (when macro
        (attribute "macro" "true"))
      (when generic
        (attribute "generic" "true"))
      (with-clix-element ("lambda-list")
        (text (format nil "~(~{~:[()~;~:*~A~]~^ ~}~)" args)))
      (with-clix-element ("returns")
        (text "**RETURN-TYPE**"))
      (clix-description doc :args args)))
  (:method (name (type (eql :macro)) args doc &key)
    (process-doc-entry name :function args doc :macro t))
  (:method (name (type (eql :generic-function)) args doc &key)
    (process-doc-entry name :function args doc :generic t))
  (:method (name (type (eql :special-var)) args doc &key)
    (with-clix-element ("special-variable")
      (clix-name-attribute name)
      (clix-description doc)))
  (:method (name (type (eql :class)) args doc &key)
    (with-clix-element ((if (subtypep name 'condition)
                            "condition"
                            "class"))
      (attribute "name" (string-downcase (princ-to-string name)))
      (clix-description doc))))

(defun make-doc-template (package &optional (output *standard-output*))
  (with-xml-output (make-character-stream-sink output)
    (processing-instruction "xml-stylesheet" "type=\"text/xsl\" href=\"clixdoc.xsl\"")
    (with-namespace ("clix" "http://bknr.net/clixdoc")
      (with-namespace ("" "http://www.w3.org/1999/xhtml")
        (with-clix-element ("documentation")
          (with-clix-element ("title")
            (text "**TITLE**"))
          (with-clix-element ("short-description")
            (text "**SHORT DESCRIPTION**"))
          (with-clix-element ("contents"))
          (with-clix-chapter ("**CHAPTER-NAME**" "**SAMPLE CHAPTER TITLE**")
            (text "**SAMPLE CHAPTER TEXT**"))
          (with-clix-chapter ("**REFERENCE**" "Reference")
            (let ((*current-doc-entries* (collect-all-doc-entries package)))
              (dolist (doc-entry *current-doc-entries*)
                (apply #'process-doc-entry doc-entry))))
          (with-clix-chapter ("index" "Symbol index")
            (with-clix-element ("index"))))))))

(defun write-doc-template (package)
  (let ((filename (make-pathname :name (string-downcase (symbol-name package))
                                 :type "xml")))
    (with-open-file (f filename :direction :output :if-exists :supersede)
      (make-doc-template package f))
    (asdf:run-shell-command "xmllint -format ~A > ~:*~A.1" (truename filename))
    (asdf:run-shell-command "mv ~A.1 ~:*~A" (truename filename))
    (truename filename)))